# A TRANSPORTATION PROBLEM
#
# This problem finds a least cost shipping schedule that meets
# requirements at markets and supplies at factories.
#
#  References:
#              Dantzig G B, "Linear Programming and Extensions."
#              Princeton University Press, Princeton, New Jersey, 1963,
#              Chapter 3-3.
set H;
/* hosts */
set S;
/* synths */
param cores{h in H} integer;
/* capacity of plant i in cases */
 param c{s in S, t in S} binary;  
/*set C{S} within S;  */
/* connection array */
var a{h in H, s in S} >= 0;
/* allocation array! */
minimize cost: 
	sum{s in S, t in S} c[s,t] -
	(
		sum{h in H, s in S, t in S: s <> t}2*(a[h,s] + a[h,t])
		- sum{h in H, s in S, t in S: s <> t}a[h,s]
		- sum{h in H, s in S, t in S: s <> t}a[h,t]
	);
#	sum{h in H, s in S, t in S}(min(a[h,s], a[h,t]));
#	(
#		a[Host1,Adc]*a[Host1,Lp1] + 
#		a[Host2,Adc]*a[Host2,Lp1] + 
#		a[Host3,Adc]*a[Host3,Lp1] +
#		a[Host1,Fm1]*a[Host1,Lp1] + 
#		a[Host2,Fm1]*a[Host2,Lp1] + 
#		a[Host3,Fm1]*a[Host3,Lp1] +
#		a[Host1,Fm1]*a[Host1,Dac] + 
#		a[Host2,Fm1]*a[Host2,Dac] + 
#		a[Host3,Fm1]*a[Host3,Dac] +
#		a[Host1,Lp1]*a[Host1,Dac] + 
#		a[Host2,Lp1]*a[Host2,Dac] + 
#		a[Host3,Lp1]*a[Host3,Dac] 
#	);
	/* sum({s in S, t in C[s],h in H}); */
/*	card(setof{s in S, t in C[s], h in H}(s,t,h,a[h,s] + a[h,t])); */
	/* card({s in S, t in C[s], h in H: a[h,s] and a[h,t]}); */
	/*	if (a[h,s] and a[h,t]) then {1} else {0} ;*/ /*: a[h,s] and a[h,t]});*/ 
/*               card({h in H, s in S, t in S: c[s,t] and a[h,s] and a[h,t]})*/
/*              card({h in H, s in S, t in S: c[s,t] and a[h,s] and a[h,t]}) */
/* sum{g in Groups, (i,w,p) in Items[g]} p*x[i];*/
/* ^^^ remotes is complicated! */
s.t. assign{s in S}: sum{h in H} a[h,s] = 1;
/* the constraint of assign it to 1 host */
s.t. corecheck{h in H}: cores[h] - sum{s in S}(a[h,s]) >= 0;
/* This avoid overload -- but what if we have to overload! */
data;

set H := Host1 Host2 Host3;

set S := Adc Fm1 Lp1 Dac;

param cores := Host1   1
               Host2   1
               Host3   2;
/*
set C[Adc] := Lp1;
set C[Fm1] := Lp1 Dac;
set C[Lp1] := Dac;
set C[Dac] := ;*/
param c :              Adc      Fm1     Lp1  Dac := 
           Adc         0        0       1    0
           Fm1         0        0       1    1
           Lp1         0        0       0    1
           Dac         0        0       0    0  ;
end
